#!/usr/bin/env python3
"""
Export Neo4j database to Cypher format for import on Nibi.
This creates a complete dump of the database as Cypher statements.
"""

from neo4j import GraphDatabase
import sys
import gzip
import os

class Neo4jExporter:
    def __init__(self, uri=None, user=None, password=None):
        # Use environment variables if not provided
        uri = uri or os.getenv('NEO4J_URI', 'bolt://localhost:7687')
        user = user or os.getenv('NEO4J_USER', 'neo4j')
        password = password or os.getenv('NEO4J_PASSWORD')
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def export_to_cypher(self, output_file):
        """Export entire database to Cypher statements."""

        print(f"Exporting database to {output_file}...")

        with gzip.open(output_file, 'wt', encoding='utf-8') as f:
            # Write header
            f.write("// Neo4j Database Export\n")
            f.write("// Canadian LOD Knowledge Graph\n")
            f.write("// Generated by export_database.py\n\n")

            # Export constraints first
            print("Exporting constraints...")
            f.write("// ============================================================\n")
            f.write("// CONSTRAINTS\n")
            f.write("// ============================================================\n\n")

            with self.driver.session() as session:
                result = session.run("SHOW CONSTRAINTS")
                for record in result:
                    # Create constraint statements
                    constraint_type = record.get("type", "")
                    entity_type = record.get("entityType", "")
                    labels = record.get("labelsOrTypes", [])
                    properties = record.get("properties", [])
                    name = record.get("name", "")

                    if constraint_type in ["UNIQUENESS", "UNIQUE"]:
                        label = labels[0] if labels else ""
                        prop = properties[0] if properties else ""
                        if label and prop:
                            f.write(f"CREATE CONSTRAINT {name} IF NOT EXISTS FOR (n:{label}) REQUIRE n.{prop} IS UNIQUE;\n")

                f.write("\n")

            # Export indexes
            print("Exporting indexes...")
            f.write("// ============================================================\n")
            f.write("// INDEXES\n")
            f.write("// ============================================================\n\n")

            with self.driver.session() as session:
                result = session.run("SHOW INDEXES")
                for record in result:
                    index_type = record.get("type", "")
                    labels = record.get("labelsOrTypes", [])
                    properties = record.get("properties", [])
                    name = record.get("name", "")

                    if index_type == "RANGE" and labels and properties:
                        label = labels[0]
                        prop = properties[0]
                        f.write(f"CREATE INDEX {name} IF NOT EXISTS FOR (n:{label}) ON (n.{prop});\n")
                    elif index_type == "TEXT" and labels and properties:
                        label = labels[0]
                        prop = properties[0]
                        f.write(f"CREATE TEXT INDEX {name} IF NOT EXISTS FOR (n:{label}) ON (n.{prop});\n")
                    elif index_type == "POINT" and labels and properties:
                        label = labels[0]
                        prop = properties[0]
                        f.write(f"CREATE POINT INDEX {name} IF NOT EXISTS FOR (n:{label}) ON (n.{prop});\n")

                f.write("\n")

            # Export nodes in batches
            print("Exporting nodes...")
            f.write("// ============================================================\n")
            f.write("// NODES\n")
            f.write("// ============================================================\n\n")

            with self.driver.session() as session:
                # Get all node labels
                result = session.run("CALL db.labels()")
                labels = [record["label"] for record in result]

                for label in labels:
                    print(f"  Exporting {label} nodes...")

                    # Count nodes
                    count_result = session.run(f"MATCH (n:{label}) RETURN count(n) as count")
                    total = count_result.single()["count"]
                    print(f"    Total: {total:,}")

                    # Export in batches of 10,000
                    batch_size = 10000
                    for skip in range(0, total, batch_size):
                        result = session.run(f"""
                            MATCH (n:{label})
                            RETURN n
                            SKIP {skip}
                            LIMIT {batch_size}
                        """)

                        for record in result:
                            node = record["n"]
                            props = dict(node.items())

                            # Convert properties to Cypher-safe format
                            prop_str = self._format_properties(props)

                            f.write(f"CREATE (:{label} {prop_str});\n")

                        if (skip + batch_size) % 100000 == 0:
                            print(f"    Exported {skip + batch_size:,} / {total:,}")

                    f.write("\n")

            # Export relationships
            print("Exporting relationships...")
            f.write("// ============================================================\n")
            f.write("// RELATIONSHIPS\n")
            f.write("// ============================================================\n\n")

            with self.driver.session() as session:
                # Get all relationship types
                result = session.run("CALL db.relationshipTypes()")
                rel_types = [record["relationshipType"] for record in result]

                for rel_type in rel_types:
                    print(f"  Exporting {rel_type} relationships...")

                    # This is complex - we need to match nodes by unique properties
                    # For now, export relationships with node matching by ID
                    # This won't work across databases, so we need a better approach

                    f.write(f"// {rel_type} relationships will be created by batch scripts\n\n")

        print(f"✓ Export complete: {output_file}")
        print(f"  File size: {self._get_file_size(output_file)}")

    def export_for_import(self, output_dir):
        """Export database in format suitable for batch import on Nibi."""
        import os
        import json

        os.makedirs(output_dir, exist_ok=True)
        print(f"Exporting database to {output_dir}...")

        with self.driver.session() as session:
            # Export Place nodes with all properties
            print("Exporting Place nodes...")
            places_file = os.path.join(output_dir, "places.json.gz")

            with gzip.open(places_file, 'wt', encoding='utf-8') as f:
                result = session.run("""
                    MATCH (p:Place)
                    RETURN p.geonameId as geonameId,
                           p.name as name,
                           p.latitude as latitude,
                           p.longitude as longitude,
                           p.countryCode as countryCode,
                           p.admin1Code as admin1Code,
                           p.admin2Code as admin2Code,
                           p.admin3Code as admin3Code,
                           p.admin4Code as admin4Code,
                           p.featureClass as featureClass,
                           p.featureCode as featureCode,
                           p.population as population,
                           p.elevation as elevation,
                           p.timezone as timezone,
                           p.modificationDate as modificationDate
                """)

                count = 0
                for record in result:
                    data = dict(record)
                    f.write(json.dumps(data) + '\n')
                    count += 1
                    if count % 100000 == 0:
                        print(f"  Exported {count:,} places...")

            print(f"✓ Exported {count:,} Place nodes")

            # Export AdminDivision nodes
            print("Exporting AdminDivision nodes...")
            admin_file = os.path.join(output_dir, "admin_divisions.json.gz")

            with gzip.open(admin_file, 'wt', encoding='utf-8') as f:
                result = session.run("""
                    MATCH (a:AdminDivision)
                    RETURN a.geonameId as geonameId,
                           a.name as name,
                           a.countryCode as countryCode,
                           a.admin1Code as admin1Code,
                           a.admin2Code as admin2Code,
                           a.admin3Code as admin3Code,
                           a.featureCode as featureCode
                """)

                count = 0
                for record in result:
                    data = dict(record)
                    f.write(json.dumps(data) + '\n')
                    count += 1

            print(f"✓ Exported {count:,} AdminDivision nodes")

            # Export Country nodes
            print("Exporting Country nodes...")
            country_file = os.path.join(output_dir, "countries.json.gz")

            with gzip.open(country_file, 'wt', encoding='utf-8') as f:
                result = session.run("""
                    MATCH (c:Country)
                    RETURN c.code as code,
                           c.name as name
                """)

                countries = [dict(record) for record in result]
                json.dump(countries, f, indent=2)

            print(f"✓ Exported {len(countries)} Country nodes")

            # Create relationship export markers (we'll rebuild these on Nibi)
            print("\nNote: Relationships will be rebuilt on Nibi using:")
            print("  - create_admin_hierarchies_batched.py")
            print("  - add_admin3_links.py")

        print(f"\n✓ Export complete: {output_dir}")
        print("Ready to transfer to Nibi!")

    def _format_properties(self, props):
        """Format properties dict as Cypher map."""
        items = []
        for key, value in props.items():
            if value is None:
                continue
            elif isinstance(value, str):
                # Escape quotes
                value = value.replace("'", "\\'")
                items.append(f"{key}: '{value}'")
            elif isinstance(value, (int, float)):
                items.append(f"{key}: {value}")
            elif isinstance(value, bool):
                items.append(f"{key}: {str(value).lower()}")
            elif isinstance(value, list):
                # Handle arrays
                formatted_list = [f"'{v}'" if isinstance(v, str) else str(v) for v in value]
                items.append(f"{key}: [{', '.join(formatted_list)}]")

        return "{" + ", ".join(items) + "}"

    def _get_file_size(self, filepath):
        """Get human-readable file size."""
        import os
        size = os.path.getsize(filepath)
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} TB"

if __name__ == "__main__":
    exporter = Neo4jExporter()

    try:
        # Export in JSON format suitable for import
        exporter.export_for_import("neo4j_export")

        print("\n" + "="*60)
        print("NEXT STEPS:")
        print("="*60)
        print("1. Transfer to Nibi:")
        print("   scp -r neo4j_export nibi:~/projects/def-jic823/CanadaNeo4j/")
        print("")
        print("2. On Nibi, create import scripts to load:")
        print("   - places.json.gz")
        print("   - admin_divisions.json.gz")
        print("   - countries.json.gz")
        print("")
        print("3. Rebuild relationships using existing scripts")

    finally:
        exporter.close()
